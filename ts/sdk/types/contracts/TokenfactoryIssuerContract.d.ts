/**
* This file was automatically generated by cosmwasm-typescript-gen@0.3.9.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the cosmwasm-typescript-gen generate command to regenerate this file.
*/
import { CosmWasmClient, ExecuteResult, SigningCosmWasmClient } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
export interface BlacklisteesResponse {
    blacklistees: StatusInfo[];
    [k: string]: unknown;
}
export interface StatusInfo {
    address: string;
    status: boolean;
    [k: string]: unknown;
}
export interface BlacklisterAllowancesResponse {
    blacklisters: StatusInfo[];
    [k: string]: unknown;
}
export interface BurnAllowanceResponse {
    allowance: number;
    [k: string]: unknown;
}
export interface BurnAllowancesResponse {
    allowances: AllowanceInfo[];
    [k: string]: unknown;
}
export interface AllowanceInfo {
    address: string;
    allowance: number;
    [k: string]: unknown;
}
export declare type Addr = string;
export interface Config {
    denom: string;
    is_frozen: boolean;
    owner: Addr;
    [k: string]: unknown;
}
export interface DenomResponse {
    denom: string;
    [k: string]: unknown;
}
export declare type ExecuteMsg = {
    change_token_factory_admin: {
        new_admin: string;
        [k: string]: unknown;
    };
} | {
    change_contract_owner: {
        new_owner: string;
        [k: string]: unknown;
    };
} | {
    set_minter: {
        address: string;
        allowance: Uint128;
        [k: string]: unknown;
    };
} | {
    set_burner: {
        address: string;
        allowance: Uint128;
        [k: string]: unknown;
    };
} | {
    set_blacklister: {
        address: string;
        status: boolean;
        [k: string]: unknown;
    };
} | {
    set_freezer: {
        address: string;
        status: boolean;
        [k: string]: unknown;
    };
} | {
    mint: {
        amount: Uint128;
        to_address: string;
        [k: string]: unknown;
    };
} | {
    burn: {
        amount: Uint128;
        [k: string]: unknown;
    };
} | {
    blacklist: {
        address: string;
        status: boolean;
        [k: string]: unknown;
    };
} | {
    freeze: {
        status: boolean;
        [k: string]: unknown;
    };
};
export declare type Uint128 = string;
export interface FreezerAllowancesResponse {
    freezers: StatusInfo[];
    [k: string]: unknown;
}
export interface InstantiateMsg {
    denom: string;
    [k: string]: unknown;
}
export interface IsBlacklistedResponse {
    status: boolean;
    [k: string]: unknown;
}
export interface IsBlacklisterResponse {
    status: boolean;
    [k: string]: unknown;
}
export interface IsFreezerResponse {
    status: boolean;
    [k: string]: unknown;
}
export interface IsFrozenResponse {
    is_frozen: boolean;
    [k: string]: unknown;
}
export interface MintAllowanceResponse {
    allowance: number;
    [k: string]: unknown;
}
export interface MintAllowancesResponse {
    allowances: AllowanceInfo[];
    [k: string]: unknown;
}
export interface OwnerResponse {
    address: string;
    [k: string]: unknown;
}
export declare type QueryMsg = {
    is_frozen: {
        [k: string]: unknown;
    };
} | {
    denom: {
        [k: string]: unknown;
    };
} | {
    owner: {
        [k: string]: unknown;
    };
} | {
    burn_allowance: {
        address: string;
        [k: string]: unknown;
    };
} | {
    burn_allowances: {
        limit?: number | null;
        start_after?: string | null;
        [k: string]: unknown;
    };
} | {
    mint_allowance: {
        address: string;
        [k: string]: unknown;
    };
} | {
    mint_allowances: {
        limit?: number | null;
        start_after?: string | null;
        [k: string]: unknown;
    };
} | {
    is_blacklisted: {
        address: string;
        [k: string]: unknown;
    };
} | {
    blacklistees: {
        limit?: number | null;
        start_after?: string | null;
        [k: string]: unknown;
    };
} | {
    is_blacklister: {
        address: string;
        [k: string]: unknown;
    };
} | {
    blacklister_allowances: {
        limit?: number | null;
        start_after?: string | null;
        [k: string]: unknown;
    };
} | {
    is_freezer: {
        address: string;
        [k: string]: unknown;
    };
} | {
    freezer_allowances: {
        limit?: number | null;
        start_after?: string | null;
        [k: string]: unknown;
    };
};
export declare type SudoMsg = {
    block_before_send: {
        amount: Coin;
        from: string;
        to: string;
        [k: string]: unknown;
    };
};
export interface Coin {
    amount: Uint128;
    denom: string;
    [k: string]: unknown;
}
export interface TokenfactoryIssuerReadOnlyInterface {
    contractAddress: string;
    isFrozen: () => Promise<IsFrozenResponse>;
    denom: () => Promise<DenomResponse>;
    owner: () => Promise<OwnerResponse>;
    burnAllowance: ({ address }: {
        address: string;
    }) => Promise<BurnAllowanceResponse>;
    burnAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<BurnAllowancesResponse>;
    mintAllowance: ({ address }: {
        address: string;
    }) => Promise<MintAllowanceResponse>;
    mintAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<MintAllowancesResponse>;
    isBlacklisted: ({ address }: {
        address: string;
    }) => Promise<IsBlacklistedResponse>;
    blacklistees: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<BlacklisteesResponse>;
    isBlacklister: ({ address }: {
        address: string;
    }) => Promise<IsBlacklisterResponse>;
    blacklisterAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<BlacklisterAllowancesResponse>;
    isFreezer: ({ address }: {
        address: string;
    }) => Promise<IsFreezerResponse>;
    freezerAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<FreezerAllowancesResponse>;
}
export declare class TokenfactoryIssuerQueryClient implements TokenfactoryIssuerReadOnlyInterface {
    client: CosmWasmClient;
    contractAddress: string;
    constructor(client: CosmWasmClient, contractAddress: string);
    isFrozen: () => Promise<IsFrozenResponse>;
    denom: () => Promise<DenomResponse>;
    owner: () => Promise<OwnerResponse>;
    burnAllowance: ({ address }: {
        address: string;
    }) => Promise<BurnAllowanceResponse>;
    burnAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<BurnAllowancesResponse>;
    mintAllowance: ({ address }: {
        address: string;
    }) => Promise<MintAllowanceResponse>;
    mintAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<MintAllowancesResponse>;
    isBlacklisted: ({ address }: {
        address: string;
    }) => Promise<IsBlacklistedResponse>;
    blacklistees: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<BlacklisteesResponse>;
    isBlacklister: ({ address }: {
        address: string;
    }) => Promise<IsBlacklisterResponse>;
    blacklisterAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<BlacklisterAllowancesResponse>;
    isFreezer: ({ address }: {
        address: string;
    }) => Promise<IsFreezerResponse>;
    freezerAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<FreezerAllowancesResponse>;
}
export interface TokenfactoryIssuerInterface extends TokenfactoryIssuerReadOnlyInterface {
    contractAddress: string;
    sender: string;
    changeTokenFactoryAdmin: ({ newAdmin }: {
        newAdmin: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    changeContractOwner: ({ newOwner }: {
        newOwner: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    setMinter: ({ address, allowance }: {
        address: string;
        allowance: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    setBurner: ({ address, allowance }: {
        address: string;
        allowance: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    setBlacklister: ({ address, status }: {
        address: string;
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    setFreezer: ({ address, status }: {
        address: string;
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    mint: ({ amount, toAddress }: {
        amount: string;
        toAddress: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    burn: ({ amount }: {
        amount: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    blacklist: ({ address, status }: {
        address: string;
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    freeze: ({ status }: {
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
}
export declare class TokenfactoryIssuerClient extends TokenfactoryIssuerQueryClient implements TokenfactoryIssuerInterface {
    client: SigningCosmWasmClient;
    sender: string;
    contractAddress: string;
    constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string);
    changeTokenFactoryAdmin: ({ newAdmin }: {
        newAdmin: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    changeContractOwner: ({ newOwner }: {
        newOwner: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    setMinter: ({ address, allowance }: {
        address: string;
        allowance: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    setBurner: ({ address, allowance }: {
        address: string;
        allowance: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    setBlacklister: ({ address, status }: {
        address: string;
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    setFreezer: ({ address, status }: {
        address: string;
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    mint: ({ amount, toAddress }: {
        amount: string;
        toAddress: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    burn: ({ amount }: {
        amount: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    blacklist: ({ address, status }: {
        address: string;
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
    freeze: ({ status }: {
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
}
//# sourceMappingURL=TokenfactoryIssuerContract.d.ts.map